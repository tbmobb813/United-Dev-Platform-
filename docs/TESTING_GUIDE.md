# United Dev Platform (UDP) â€” Testing Guide

## Overview

This testing guide documents end-to-end, integration, unit, and operational testing practices for
the United Dev Platform (UDP) monorepo. It covers the web (Next.js), mobile (Expo/React Native), API
(Express + Yjs WebSocket), desktop (Electron), shared packages (editor-core, ui, types), AI
components, database, and CI automation.

Goals:

- Ensure real-time collaboration (Yjs) works across web/mobile/desktop without duplicated runtimes.
- Verify critical user flows (editor collaboration, auth, file management, AI flows).
- Provide repeatable test environments and automation for CI.

## Test Audience & Scope

- Developers: unit tests, component tests, local integration tests.
- QA: E2E, cross-platform tests, smoke tests.
- DevOps: CI/CD, performance, and production-readiness checks.

Primary areas to test:

- Real-time collaboration (Yjs + y-websocket)
- Editor features (monaco integration, awareness, cursors)
- Authentication & session flows
- API endpoints and DB migrations (Prisma)
- Mobile sync and presence
- Shared packages (editor-core, ui, types)
- AI manager flows and privacy controls
- Packaging/builds (duplicated deps, production bundles)

---

## Sprint / Iteration Testing Patterns

### UX & Validation

- Centralized validation rules live in `packages/types`/`packages/config` or a shared `validation`
  barrel.
- Standardize user feedback: `packages/ui` and `packages/ui-native` include toast/popup patterns â€”
  validate consistency.

### Collaboration & Presence

- `packages/editor-core` must expose deterministic behaviors for DocumentManager and Awareness
  utilities.
- Always test multiple clients joining the same room and merging updates.

---

## Testing Environment Setup

### Prerequisites

- Node.js (per repo `.nvmrc` if present) and pnpm installed
- Docker (optional) for local DB and infra
- Expo Go for mobile manual tests
- A browser for web testing

### Local dev steps (quick)

```bash
pnpm install
cp .env.example .env
# edit .env for local DB and secrets (NEXTAUTH_SECRET, DATABASE_URL)
pnpm -w prisma generate # if required
# run API
pnpm --filter @udp/api dev
# run web
pnpm --filter @udp/web dev
# run mobile
pnpm --filter @udp/mobile start
```

### Test data

- Use `packages/db` and `prisma/seed` helpers where available.
- Keep mock fixtures in `/__mocks__/` or `tests/fixtures` per package; prefer workspace-wide
  `tests/fixtures` for common mocks.

---

## Test Types & Tools

- Unit tests: Jest + ts-jest. Place under `__tests__` in each package. Keep them fast and
  deterministic.
- Component tests: React Testing Library (web) and React Native Testing Library (mobile).
- Integration tests: Jest or Vitest for package-to-package integration (editor-core <-> yjs
  provider).
- E2E tests: Playwright (web), Detox or Appium for mobile.
- Visual regression: Playwright snapshots / Chromatic for component library.
- Load/perf: k6 or Artillery for API and WebSocket concurrency scenarios.
- Lint & typecheck: ESLint + TypeScript (run in CI pre-merge).

---

## Feature Testing Checklist (Priority-Driven)

### ðŸ”´ HIGH PRIORITY â€” Core Collaboration & Platform Flows

1. Real-time Collaboration (Yjs)

- [ ] Two clients (web+mobile) can join same room and see real-time updates.
- [ ] Cursor/selection and presence are synchronized (awareness API).
- [ ] Persistence / offline re-sync via `y-indexeddb` + WebSocket replay works.
- [ ] Single Yjs runtime in production bundles (scan for duplicates in build output). Validate with
      production sourcemaps.
- [ ] Handle conflict merges: concurrent edits in the same document.

2. Editor Features

- [ ] Monaco loads and attaches to Yjs document without crashing.
- [ ] DocumentManager API handles open/close/reconnect cycle.
- [ ] Undo/redo behavior is consistent across clients.

3. API & WebSocket

- [ ] Yjs websocket provider endpoint responds and relays updates.
- [ ] Health checks for WebSocket server, correct authentication (if enabled).
- [ ] API endpoints for AI and management return expected shapes and handle errors gracefully.

4. Authentication & Sessions

- [ ] Sign-in flows (NextAuth) â€” dev, OAuth and session cookies.
- [ ] Protected API routes return 401 when unauthenticated.
- [ ] Session persistence across refresh.

5. Database & Migrations (Prisma)

- [ ] `prisma migrate dev` works locally and `prisma migrate deploy` for production.
- [ ] Seed scripts are idempotent.
- [ ] Types generated by Prisma are in sync with packages that import `@prisma/client`.

6. Mobile synchronization

- [ ] Expo client joins Yjs room and receives updates.
- [ ] Backgrounding/foregrounding handles reconnection.

7. Packaging & Build

- [ ] Production web build (`next build`) should be analyzed for duplicate runtime (Yjs). Use
      `next build --profile` and source maps.
- [ ] Mobile release build doesn't inline a second Yjs copy.

### ðŸŸ¡ MEDIUM PRIORITY â€” AI, File System, Git, UI

1. AI flows

- [ ] AIManager request/response flow handles provider errors and rate limits.
- [ ] Prompt templates are properly typed and validated.
- [ ] Ensure no secrets leak into client bundles.

2. File system & Git packages

- [ ] File read/write operations on `packages/filesystem` work for local and hosted backends.
- [ ] Basic git operations (clone, commit, status via `packages/git`) are mocked in unit tests.

3. UI components

- [ ] Snapshot tests for shared components in `packages/ui` and `packages/ui-native`.
- [ ] Accessibility (aria labels, roles) for web components.

### ðŸŸ¢ LOW PRIORITY â€” Performance, Accessibility, Edge Polishing

- [ ] Keyboard navigation and screen-reader paths.
- [ ] Memory/leak detection for long-lived collaboration sessions.
- [ ] Mobile battery/foreground optimizations.

---

## Testing Scenarios (Example Playbooks)

### Scenario A â€” Two-Client Collaboration (Web + Mobile)

1. Start API + WebSocket server.
2. Start web client (open in Chrome) and mobile client (Expo).
3. Create document in web; mobile client joins same room ID.
4. Type concurrently on both clients, verify sync, cursor and selection presence.
5. Simulate network cut on mobile, then restore; verify merge and no data loss.

### Scenario B â€” AI Assistant Flow

1. Trigger an AI prompt from web editor.
2. Validate request body to AI backend; mock provider and return deterministic response.
3. Verify UI rendering of suggestions and that accepted suggestion updates the Yjs document.

### Scenario C â€” Production Bundle Check (Yjs duplication)

1. Build production web app: `pnpm --filter @udp/web build`.
2. Generate and upload source maps (or inspect locally) and scan bundled modules for `yjs`
   duplicates.
3. If duplicates found, verify package aliases, dedupe strategies, or move to peerDeps.

---

## Edge Cases & Error Handling

### Network/Connectivity

- [ ] Offline editing: writes to local IndexedDB and re-syncs on reconnect.
- [ ] Partial failures: WebSocket disconnects, re-auth failures.

### Resource Limits & Corruption

- [ ] Large document edits (huge insertions) degrade gracefully.
- [ ] Corrupted local storage: fall back to safe state and rehydrate.

### Security & Privacy Edge Cases

- [ ] Ensure AI request logs never include secrets or user PII.
- [ ] Confirm access control on WebSocket rooms (private vs public rooms).

---

## Performance & Load Testing

- WebSocket concurrency tests: simulate 100+ connected clients to validate server scaling.
- Document synchronization throughput (ops/sec) under concurrent edits.
- API rate-limits, AI provider latency/resilience.

Tools: k6, Artillery, Locust (for Python-based teams).

---

## Security Testing Checklist

- Secrets not bundled into client code
- Proper CORS and CSRF protections for API
- Authentication flows tested (token expiry, refresh)
- Database access controls and least-privilege checks

---

## Test Automation & CI Recommendations

1. GitHub Actions (recommended) workflow per PR:
   - Checkout + pnpm install
   - Run `pnpm -w lint` and `pnpm -w typecheck`
   - Run `pnpm -w test` (Turbo will run tests per package)
   - Run `pnpm --filter @udp/web build` and run a bundle scan (script) to check for duplicated
     runtime modules (Yjs)
   - Optionally run Playwright tests for web and Detox for mobile in dedicated job(s)

2. Test caching: use Turbo cache or action cache for node_modules and build artifacts.
3. Coverage: collect per-package coverage and fail CI if overall coverage falls below a threshold
   (e.g., 60% initially).

---

## Bug Report Template (Use in issues)

**Title:** [Area] Short description

**Environment:**

- Platform (web/mobile/desktop)
- Browser / OS
- App version / Commit hash

**Steps to Reproduce:**

1. ...
2. ...
3. ...

**Expected:**

**Actual:**

**Logs / Stack trace:**

**Notes / Attachments:**

---

## Production Readiness Checklist

- [ ] All high-priority tests pass in CI
- [ ] Build analysis shows no duplicate Yjs runtime in final bundles
- [ ] Security scan completed
- [ ] Performance tests meet SLA targets
- [ ] Documentation updated (README, ENVIRONMENT)

---

## Continuous Testing & Maintenance

- Run automated tests on every PR and nightly for long-running/performance suites.
- Regularly maintain and rotate test fixtures and seeds.
- Keep the testing guide in `docs/TESTING_GUIDE.md` updated as features change.

---

## Appendix: Quick Commands

Run lint, typecheck, and tests across workspace:

```bash
pnpm -w lint
pnpm -w typecheck
pnpm -w test
```

Run a single package tests (examples):

```bash
pnpm --filter @udp/web test
pnpm --filter @udp/mobile test
pnpm --filter @udp/editor-core test
```

Build web and inspect bundles:

```bash
pnpm --filter @udp/web build
# inspect .next/static or use source-map-explorer for deeper analysis
```

---

If you'd like, I can also:

- Add a GitHub Actions workflow that runs this pipeline (lint/typecheck/test/build).
- Create a small script to scan production bundles for duplicate Yjs instances and fail CI if found.
- Add example Playwright and Detox E2E setups.

Would you like me to add the CI workflow next or the duplicate-Yjs detection script?
